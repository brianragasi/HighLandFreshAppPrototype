class InventoryAPI {    constructor() {        this.baseURL = '../api';        this.endpoints = {            inventory: '/ProductsAPI.php?inventory=1',            inventoryStats: '/ProductsAPI.php?inventory_stats=1',            lowStockOnly: '/ProductsAPI.php?inventory=1&low_stock_only=1'        };    }    async getInventory(options = {}) {        try {            let url = this.baseURL + this.endpoints.inventory;            if (options.lowStockOnly) {                url = this.baseURL + this.endpoints.lowStockOnly;            }            const response = await axios.get(url, {                withCredentials: true,                headers: {                    'Content-Type': 'application/json'                }            });            return response.data;        } catch (error) {            console.error('Error fetching inventory:', error);            throw this.handleApiError(error);        }    }    async getInventoryStats() {        try {            const response = await axios.get(this.baseURL + this.endpoints.inventoryStats, {                withCredentials: true,                headers: {                    'Content-Type': 'application/json'                }            });            return response.data;        } catch (error) {            console.error('Error fetching inventory stats:', error);            throw this.handleApiError(error);        }    }    async searchInventory(searchTerm, options = {}) {        try {            const inventoryResponse = await this.getInventory(options);            if (!inventoryResponse.success) {                throw new Error(inventoryResponse.message || 'Failed to fetch inventory');            }            const filteredData = inventoryResponse.data.filter(product => {                const searchLower = searchTerm.toLowerCase();                return (                    product.name.toLowerCase().includes(searchLower) ||                    product.sku.toLowerCase().includes(searchLower) ||                    (product.category && product.category.toLowerCase().includes(searchLower)) ||                    (product.supplier_name && product.supplier_name.toLowerCase().includes(searchLower))                );            });            return {                success: true,                data: filteredData,                count: filteredData.length            };        } catch (error) {            console.error('Error searching inventory:', error);            throw this.handleApiError(error);        }    }    async filterByStockStatus(filterType) {        try {            let inventoryResponse;            switch (filterType) {                case 'low_stock':                    inventoryResponse = await this.getInventory({ lowStockOnly: true });                    break;                case 'out_of_stock':                    inventoryResponse = await this.getInventory();                    if (inventoryResponse.success) {                        inventoryResponse.data = inventoryResponse.data.filter(product =>                             product.quantity_on_hand === 0                        );                        inventoryResponse.count = inventoryResponse.data.length;                    }                    break;                case 'healthy':                    inventoryResponse = await this.getInventory();                    if (inventoryResponse.success) {                        inventoryResponse.data = inventoryResponse.data.filter(product =>                             product.quantity_on_hand > product.reorder_level                        );                        inventoryResponse.count = inventoryResponse.data.length;                    }                    break;                case 'all':                default:                    inventoryResponse = await this.getInventory();                    break;            }            return inventoryResponse;        } catch (error) {            console.error('Error filtering inventory:', error);            throw this.handleApiError(error);        }    }    async getFilteredInventory(searchTerm = '', filterType = 'all') {        try {            let inventoryResponse = await this.filterByStockStatus(filterType);            if (!inventoryResponse.success) {                throw new Error(inventoryResponse.message || 'Failed to fetch inventory');            }            if (searchTerm.trim()) {                const searchLower = searchTerm.toLowerCase();                inventoryResponse.data = inventoryResponse.data.filter(product => {                    return (                        product.name.toLowerCase().includes(searchLower) ||                        product.sku.toLowerCase().includes(searchLower) ||                        (product.category && product.category.toLowerCase().includes(searchLower)) ||                        (product.supplier_name && product.supplier_name.toLowerCase().includes(searchLower))                    );                });                inventoryResponse.count = inventoryResponse.data.length;            }            return inventoryResponse;        } catch (error) {            console.error('Error getting filtered inventory:', error);            throw this.handleApiError(error);        }    }    handleApiError(error) {        if (error.response) {            const status = error.response.status;            const data = error.response.data;            switch (status) {                case 401:                    return new Error('Authentication required. Please log in again.');                case 403:                    return new Error('Access denied. Inventory Staff or Administrator access required.');                case 404:                    return new Error('Inventory service not found.');                case 500:                    return new Error('Server error. Please try again later.');                default:                    return new Error(data?.message || `HTTP Error ${status}`);            }        } else if (error.request) {            return new Error('Network error. Please check your connection.');        } else {            return new Error(error.message || 'An unexpected error occurred.');        }    }    validateInventoryData(data) {        if (!data || !Array.isArray(data)) {            return false;        }        return data.every(item =>             item.hasOwnProperty('product_id') &&            item.hasOwnProperty('name') &&            item.hasOwnProperty('quantity_on_hand') &&            item.hasOwnProperty('reorder_level') &&            item.hasOwnProperty('low_stock')        );    }}if (typeof module !== 'undefined' && module.exports) {    module.exports = InventoryAPI;}