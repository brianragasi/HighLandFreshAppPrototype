class PurchaseOrderAPI {    constructor() {        this.baseURL = '../api/PurchaseOrdersAPI.php';        this.suppliersURL = '../api/SuppliersAPI.php';        this.productsURL = '../api/ProductsAPI.php';        axios.defaults.withCredentials = true;        axios.defaults.headers.common['Content-Type'] = 'application/json';        axios.defaults.timeout = 30000;     }    async getAllPurchaseOrders(filters = {}) {        try {            const response = await axios.get(this.baseURL, {                params: filters            });            const data = response.data;            if (typeof data === 'string') {                try {                    return JSON.parse(data);                } catch (_) {                    return { success: false, message: (data || '').toString().slice(0, 500) };                }            }            return data;        } catch (error) {            console.error('Error fetching purchase orders:', error);            throw error;        }    }    async createPurchaseOrder(poData) {        try {            const response = await axios.post(this.baseURL, poData);            const data = response.data;            if (typeof data === 'string') {                try {                    return JSON.parse(data);                } catch (_) {                    return { success: false, message: (data || '').toString().slice(0, 500) };                }            }            return data;        } catch (error) {            console.error('Error creating purchase order:', error);            throw error;        }    }    async updatePurchaseOrder(poId, updateData) {        try {            const response = await axios.put(`${this.baseURL}?id=${poId}`, updateData);            return response.data;        } catch (error) {            console.error('Error updating purchase order:', error);            throw error;        }    }    async getPurchaseOrderDetails(poId) {        try {            const response = await axios.get(`${this.baseURL}`, { params: { id: poId } });            const data = response.data;            if (typeof data === 'string') {                try { return JSON.parse(data); } catch (_) { return { success: false, message: data.slice(0,500) }; }            }            return data;        } catch (error) {            console.error('Error fetching PO details:', error);            throw error;        }    }    async updatePurchaseOrderStatus(poId, statusName) {        return this.updatePurchaseOrder(poId, { status: statusName });    }    async receiveDelivery(poId, deliveryData) {        try {            const response = await axios.put(`${this.baseURL}?id=${poId}&action=receive_delivery`, deliveryData);            const data = response.data;            if (typeof data === 'string') {                try {                    return JSON.parse(data);                } catch (_) {                    return { success: false, message: (data || '').toString().slice(0, 500) };                }            }            return data;        } catch (error) {            console.error('Error receiving delivery:', error);            throw error;        }    }    async resendPurchaseOrderEmail(poId) {        return { success: false, message: 'Email functionality is temporarily disabled.' };    }    async getAllSuppliers() {        try {            const response = await axios.get(this.suppliersURL);            return response.data;        } catch (error) {            console.error('Error fetching suppliers:', error);            throw error;        }    }    async getAllProducts(filters = {}) {        try {            const response = await axios.get(this.productsURL, {                params: filters            });            return response.data;        } catch (error) {            console.error('Error fetching products:', error);            throw error;        }    }    async getInventoryData() {        try {            const response = await axios.get(this.productsURL, {                params: { operation: 'getInventory' }            });            return response.data;        } catch (error) {            console.error('Error fetching inventory data:', error);            throw error;        }    }    generateStatistics(orders) {        const stats = {            total: orders.length,            pending: 0,            inTransit: 0,            received: 0,            totalValue: 0        };        orders.forEach(order => {            stats.totalValue += parseFloat(order.total_amount || 0);            switch (order.status) {                case 'PO Sent':                case 'PO Confirmed':                    stats.pending++;                    break;                case 'PO Partially Received':                    stats.inTransit++;                    break;                case 'PO Received':                    stats.received++;                    break;            }        });        return stats;    }    formatCurrency(amount) {        return new Intl.NumberFormat('en-PH', {            style: 'currency',            currency: 'PHP'        }).format(amount || 0);    }    formatDate(dateString) {        if (!dateString) return '-';        const date = new Date(dateString);        return date.toLocaleDateString('en-US', {            year: 'numeric',            month: 'short',            day: 'numeric'        });    }    getStatusBadgeClass(status) {        switch (status) {            case 'PO Draft':                return 'bg-secondary';            case 'PO Sent':                return 'bg-primary';            case 'PO Confirmed':                return 'bg-info';            case 'PO Partially Received':                return 'bg-warning';            case 'PO Received':                return 'bg-success';            case 'PO Cancelled':                return 'bg-danger';            default:                return 'bg-secondary';        }    }    handleError(error) {        if (error.response) {            switch (error.response.status) {                case 401:                    return 'Session expired. Please log in again.';                case 403:                    return 'Access denied. Insufficient permissions.';                case 404:                    return 'Resource not found.';                case 422:                    return error.response.data?.message || 'Validation error.';                case 500:                    return 'Server error. Please try again later.';                default:                    return error.response.data?.message || 'An error occurred.';            }        } else if (error.request) {            return 'Network error. Please check your connection.';        } else {            return 'An unexpected error occurred.';        }    }    validatePurchaseOrderData(poData) {        const errors = [];        if (!poData.supplier_id || poData.supplier_id === '') {            errors.push('Please select a supplier');        }        if (!poData.items || !Array.isArray(poData.items) || poData.items.length === 0) {            errors.push('Please add at least one item to the purchase order');        } else {            poData.items.forEach((item, index) => {                if (!item.product_id || item.product_id === '') {                    errors.push(`Item ${index + 1}: Product is required`);                }                if (!item.quantity || parseFloat(item.quantity) <= 0) {                    errors.push(`Item ${index + 1}: Quantity must be greater than 0`);                }                if (!item.unit_cost || parseFloat(item.unit_cost) <= 0) {                    errors.push(`Item ${index + 1}: Unit cost must be greater than 0`);                }            });        }        if (poData.expected_delivery_date) {            const deliveryDate = new Date(poData.expected_delivery_date);            const today = new Date();            today.setHours(0, 0, 0, 0);            if (deliveryDate < today) {                errors.push('Expected delivery date cannot be in the past');            }        }        return {            isValid: errors.length === 0,            errors        };    }}