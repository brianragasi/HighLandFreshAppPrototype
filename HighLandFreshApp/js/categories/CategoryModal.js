class CategoryModal {    constructor(categoryAPI, categoryRenderer) {        this.api = categoryAPI;        this.categoryRenderer = categoryRenderer;        this.modal = document.getElementById('categoryModal');        this.form = document.getElementById('categoryForm');        this.deleteModal = document.getElementById('deleteCategoryModal');        this.isEditMode = false;        this.currentCategoryId = null;        this.initializeEventListeners();    }    initializeEventListeners() {        if (this.form) {            this.form.addEventListener('submit', (e) => this.handleFormSubmit(e));        }        this.setupFormValidation();        this.setupDeleteHandlers();        this.setupSearchAndFilter();        if (this.modal) {            this.modal.addEventListener('show.bs.modal', () => this.onModalShow());            this.modal.addEventListener('hidden.bs.modal', () => {                console.log('Category modal hidden event triggered');                this.onModalHide();                setTimeout(() => this.#forceModalCleanup(), 50);            });            this.modal.addEventListener('hide.bs.modal', () => {                console.log('Category modal hide event triggered');            });        }        if (this.deleteModal) {            this.deleteModal.addEventListener('hidden.bs.modal', () => {                console.log('Delete category modal hidden event triggered');                setTimeout(() => this.#forceModalCleanup(), 50);            });        }        this.setupParentCategoryValidation();    }    setupFormValidation() {        const categoryNameInput = document.getElementById('categoryName');        const descriptionInput = document.getElementById('categoryDescription');        if (categoryNameInput) {            categoryNameInput.addEventListener('input', (e) => this.validateCategoryName(e.target));            categoryNameInput.addEventListener('blur', (e) => this.validateCategoryName(e.target));        }        if (descriptionInput) {            descriptionInput.addEventListener('input', (e) => this.validateDescription(e.target));        }        this.setupParentCategoryValidation();    }    setupParentCategoryValidation() {        const parentSelect = document.getElementById('parentCategoryId');        if (parentSelect) {            parentSelect.addEventListener('change', () => this.validateParentCategory());        }    }    validateParentCategory() {        const parentSelect = document.getElementById('parentCategoryId');        const selectedParentId = parentSelect.value;        if (this.isEditMode && selectedParentId && this.currentCategoryId) {            if (selectedParentId === this.currentCategoryId.toString()) {                this.showFieldError('parentCategoryId', 'Category cannot be its own parent');                parentSelect.value = '';                return false;            }        }        this.clearFieldError('parentCategoryId');        return true;    }    setupDeleteHandlers() {        const softDeleteBtn = document.getElementById('softDeleteCategoryBtn');        const hardDeleteBtn = document.getElementById('hardDeleteCategoryBtn');        if (softDeleteBtn) {            softDeleteBtn.addEventListener('click', () => this.handleCategoryDelete(false));        }        if (hardDeleteBtn) {            hardDeleteBtn.addEventListener('click', () => this.handleCategoryDelete(true));        }    }    setupSearchAndFilter() {        const searchInput = document.getElementById('categorySearch');        const statusFilter = document.getElementById('categoryStatusFilter');        if (searchInput) {            searchInput.addEventListener('input', () => this.applyFilters());        }        if (statusFilter) {            statusFilter.addEventListener('change', () => this.applyFilters());        }    }    onModalShow() {        this.refreshCategories();    }    onModalHide() {        this.resetForm();    }    async handleFormSubmit(e) {        e.preventDefault();        if (!this.validateForm()) {            console.warn('Form validation failed');            return;        }        if (!this.form) {            console.error('Category form not found');            this.showErrorMessage('Form not found. Please refresh the page and try again.');            return;        }        const formData = new FormData(this.form);        const hiddenId = formData.get('categoryId');        if (!this.isEditMode && hiddenId) {            console.warn('[CategoryModal] Detected existing categoryId in form while not in edit mode. Forcing update mode to prevent duplicate category creation.');            this.isEditMode = true;            this.currentCategoryId = parseInt(hiddenId, 10) || this.currentCategoryId;            this.updateFormTitle();        }        const categoryData = {            category_name: formData.get('categoryName')?.trim(),            description: formData.get('categoryDescription')?.trim() || '',            parent_category_id: formData.get('parentCategoryId') || null,            is_active: formData.get('categoryActive') === 'on' ? 1 : 0        };        console.log('Form submission debug:', {            isEditMode: this.isEditMode,            currentCategoryId: this.currentCategoryId,            categoryData: categoryData,            formData: Object.fromEntries(formData.entries())        });        try {            this.showSubmitProgress(true);            let result;            if (this.isEditMode && this.currentCategoryId) {                result = await this.api.updateCategory(this.currentCategoryId, categoryData);            } else {                result = await this.api.createCategory(categoryData);            }            if (result && result.success) {                console.log('[CategoryModal] Form submission successful:', result);                const wasEditMode = this.isEditMode;                const editedCategoryId = this.currentCategoryId;                this.resetForm();                this.switchToList();                const eventType = wasEditMode ? 'categoryUpdated' : 'categoryCreated';                console.log('[CategoryModal] Dispatching event:', eventType, 'for category:', result.data);                document.dispatchEvent(new CustomEvent(eventType, {                    detail: result.data                }));                this.showSuccessMessage(wasEditMode ? 'Category updated successfully!' : 'Category created successfully!');                const searchInput = document.getElementById('categorySearch');                const statusFilter = document.getElementById('categoryStatusFilter');                const hadSearchTerm = searchInput?.value || '';                const hadStatusFilter = statusFilter?.value || '';                if (hadSearchTerm) {                    console.log('[CategoryModal] Temporarily clearing search filter to show updated category');                    searchInput.value = '';                }                if (hadStatusFilter && hadStatusFilter !== '') {                    console.log('[CategoryModal] Temporarily clearing status filter to show updated category');                    statusFilter.value = '';                }                setTimeout(async () => {                    console.log('[CategoryModal] Starting coordinated refresh after', wasEditMode ? 'update' : 'create');                    if (window.categoryManager) {                        console.log('[CategoryModal] Triggering CategoryManager refresh');                        await window.categoryManager.loadCategories();                        console.log('[CategoryModal] Using CategoryManager data for modal refresh');                        await this.refreshCategories(false);                     } else {                        await this.refreshCategories(true);                    }                    console.log('[CategoryModal] Coordinated refresh completed');                }, 200);            } else {                throw new Error(result?.message || 'Operation failed');            }        } catch (error) {            console.error('Category submission error:', error);            let errorMessage = 'An error occurred while saving the category';            if (error.response) {                const status = error.response.status;                const data = error.response.data;                switch (status) {                    case 409:                        errorMessage = data.message || 'A category with this name already exists. Please choose a different name.';                        break;                    case 400:                        errorMessage = data.message || 'Invalid category data. Please check your input.';                        break;                    case 404:                        errorMessage = 'Category not found. It may have been deleted by another user.';                        break;                    case 403:                        errorMessage = 'You do not have permission to perform this action.';                        break;                    default:                        errorMessage = data.message || `Server error (${status}). Please try again.`;                }            } else if (error.message) {                errorMessage = error.message;            }            this.showErrorMessage(errorMessage);        } finally {            this.showSubmitProgress(false);        }    }    async handleCategoryDelete(hardDelete) {        const deleteBtn = hardDelete ?             document.getElementById('hardDeleteCategoryBtn') :             document.getElementById('softDeleteCategoryBtn');        if (!this.currentDeleteCategoryId) {            console.error('No category selected for deletion');            return;        }        this.setDeleteLoading(deleteBtn, true);        try {            const options = {                 hard_delete: hardDelete,                force: this.currentDeleteForce || false             };            const result = await this.api.deleteCategory(this.currentDeleteCategoryId, options);            if (result && result.success) {                this.showSuccessMessage(result.message || `Category ${hardDelete ? 'deleted' : 'deactivated'} successfully!`);                this.hideDeleteModal();                document.dispatchEvent(new CustomEvent('categoryDeleted', {                    detail: { categoryId: this.currentDeleteCategoryId, hardDelete }                }));                setTimeout(async () => {                    await this.refreshCategories(true);                }, 200);            } else {                if (result && result.dependencies) {                    this.showDependenciesWarning(result);                } else {                    throw new Error(result?.message || 'Failed to delete category');                }            }        } catch (error) {            console.error('Category delete error:', error);            this.showErrorMessage(error.message || 'An error occurred while deleting the category');        } finally {            this.setDeleteLoading(deleteBtn, false);        }    }    showDependenciesWarning(result) {        const content = document.getElementById('categoryDeleteContent');        if (content) {            content.innerHTML = `                <div class="alert alert-warning">                    <h6><i class="bi bi-exclamation-triangle"></i> Category Has Dependencies</h6>                    <p>${result.message}</p>                    <ul>                        ${result.dependencies.products > 0 ? `<li>${result.dependencies.products} products assigned</li>` : ''}                        ${result.dependencies.subcategories > 0 ? `<li>${result.dependencies.subcategories} subcategories</li>` : ''}                    </ul>                </div>                <div class="form-check">                    <input class="form-check-input" type="checkbox" id="forceDeleteCheck">                    <label class="form-check-label text-danger" for="forceDeleteCheck">                        Force delete and remove all dependencies                    </label>                </div>            `;            const forceCheck = document.getElementById('forceDeleteCheck');            if (forceCheck) {                forceCheck.addEventListener('change', (e) => {                    this.currentDeleteForce = e.target.checked;                });            }        }    }    validateForm() {        if (!this.form) {            console.error('Form not available for validation');            return false;        }        const categoryNameInput = document.getElementById('categoryName');        const descriptionInput = document.getElementById('categoryDescription');        let isValid = true;        if (!this.validateCategoryName(categoryNameInput)) {            isValid = false;        }        if (!this.validateDescription(descriptionInput)) {            isValid = false;        }        console.log('Form validation result:', isValid);        return isValid;    }    validateCategoryName(input) {        if (!input) {            console.warn('Category name input field not found');            return false;        }        const value = input.value.trim();        let isValid = true;        let message = '';        if (value.length === 0) {            isValid = false;            message = 'Category name is required';        } else if (value.length > 100) {            isValid = false;            message = 'Category name must be 100 characters or less';        } else if (value.length < 2) {            isValid = false;            message = 'Category name must be at least 2 characters long';        }        this.setInputValidation(input, isValid, message);        return isValid;    }    validateDescription(input) {        if (!input) return true;        const value = input.value.trim();        let isValid = true;        let message = '';        if (value.length > 255) {            isValid = false;            message = 'Description must be 255 characters or less';        }        this.setInputValidation(input, isValid, message);        return isValid;    }    setInputValidation(input, isValid, message) {        const feedback = input.parentElement.querySelector('.invalid-feedback');        if (isValid) {            input.classList.remove('is-invalid');            input.classList.add('is-valid');            if (feedback) feedback.textContent = '';        } else {            input.classList.remove('is-valid');            input.classList.add('is-invalid');            if (feedback) feedback.textContent = message;        }    }    displayValidationErrors(errors) {        Object.keys(errors).forEach(fieldName => {            const input = document.getElementById(fieldName) ||                          document.querySelector(`[name="${fieldName}"]`);            if (input) {                this.setInputValidation(input, false, errors[fieldName]);            }        });    }    setFormLoading(loading) {        const saveBtn = document.getElementById('saveCategoryBtn');        const spinner = document.getElementById('categorySaveSpinner');        const saveText = document.getElementById('saveCategoryText');        if (saveBtn) saveBtn.disabled = loading;        if (spinner) spinner.classList.toggle('d-none', !loading);        if (saveText) saveText.textContent = loading ? 'Saving...' : (this.isEditMode ? 'Update Category' : 'Save Category');    }    setDeleteLoading(button, loading) {        if (!button) return;        const spinner = button.querySelector('.spinner-border');        button.disabled = loading;        if (spinner) {            spinner.classList.toggle('d-none', !loading);        }    }    applyFilters() {        const searchTerm = document.getElementById('categorySearch')?.value || '';        const statusFilter = document.getElementById('categoryStatusFilter')?.value || '';        this.categoryRenderer.filterCategoriesTable(searchTerm, statusFilter);    }    resetForm() {        if (this.form) {            this.form.reset();            this.form.classList.remove('was-validated');            this.form.querySelectorAll('.is-valid, .is-invalid').forEach(input => {                input.classList.remove('is-valid', 'is-invalid');            });            this.form.querySelectorAll('.invalid-feedback').forEach(feedback => {                feedback.textContent = '';            });        }        this.isEditMode = false;        this.currentCategoryId = null;        this.updateFormTitle();    }    updateFormTitle() {        const saveText = document.getElementById('saveCategoryText');        const tabButton = document.getElementById('add-category-tab');        if (this.isEditMode) {            if (saveText) saveText.textContent = 'Update Category';            if (tabButton) tabButton.innerHTML = '<i class="bi bi-pencil"></i> Edit Category';        } else {            if (saveText) saveText.textContent = 'Save Category';            if (tabButton) tabButton.innerHTML = '<i class="bi bi-plus-circle"></i> Add Category';        }    }    switchToList() {        const listTab = document.getElementById('categories-list-tab');        if (listTab) {            const tab = new bootstrap.Tab(listTab);            tab.show();        }    }    switchToForm() {        const formTab = document.getElementById('add-category-tab');        if (formTab) {            const tab = new bootstrap.Tab(formTab);            tab.show();        }    }    async refreshCategories(forceRefresh = false) {        if (!this.categoryRenderer) {            console.warn('CategoryRenderer not available for refresh');            return;        }        try {            if (typeof this.categoryRenderer.showLoadingState === 'function') {                this.categoryRenderer.showLoadingState();            }            let categories = [];            if (forceRefresh) {                console.log('[CategoryModal] Force refreshing categories from API');                if (this.api && typeof this.api.loadCategoriesWithStats === 'function') {                    categories = await this.api.loadCategoriesWithStats();                    console.log('[CategoryModal] Fresh categories loaded:', categories.length, 'categories');                    if (window.categoryManager) {                        window.categoryManager.categories = categories;                        console.log('[CategoryModal] Updated CategoryManager cache');                    }                } else if (this.api && typeof this.api.getCategories === 'function') {                    const result = await this.api.getCategories();                    categories = (result && result.success) ? result.data : [];                    console.log('[CategoryModal] Fresh categories loaded (fallback):', categories.length, 'categories');                    if (window.categoryManager) {                        window.categoryManager.categories = categories;                        console.log('[CategoryModal] Updated CategoryManager cache (fallback)');                    }                }            } else {                if (window.categoryManager && Array.isArray(window.categoryManager.categories) && window.categoryManager.categories.length) {                    categories = window.categoryManager.categories;                    console.log('[CategoryModal] Using categories from CategoryManager cache', categories);                } else {                    if (this.api && typeof this.api.loadCategoriesWithStats === 'function') {                        console.log('[CategoryModal] Fetching categories with stats for modal');                        categories = await this.api.loadCategoriesWithStats();                    } else if (this.api && typeof this.api.getCategories === 'function') {                        console.log('[CategoryModal] Fallback: getCategories() (may lack stats)');                        const result = await this.api.getCategories();                        categories = (result && result.success) ? result.data : [];                    }                }            }            if (!categories || categories.length === 0) {                console.warn('[CategoryModal] No categories found after refresh - this may indicate an API issue');                console.warn('[CategoryModal] forceRefresh was:', forceRefresh);                console.warn('[CategoryModal] API object:', this.api);                this.showAlert('warning', 'No categories found. The category may have been updated but is not visible due to a refresh issue.');                if (typeof this.categoryRenderer.showEmptyState === 'function') {                    this.categoryRenderer.showEmptyState();                }                return;            }            console.log('[CategoryModal] Rendering', categories.length, 'categories to table');            console.log('[CategoryModal] Sample category data:', categories[0]);            if (typeof this.categoryRenderer.renderCategoriesTable === 'function') {                this.categoryRenderer.renderCategoriesTable(categories);            }            if (typeof this.categoryRenderer.renderParentCategoryOptions === 'function') {                this.categoryRenderer.renderParentCategoryOptions(categories, this.currentCategoryId);            }            const searchTerm = document.getElementById('categorySearch')?.value || '';            const statusFilter = document.getElementById('categoryStatusFilter')?.value || '';            console.log('[CategoryModal] Current filters - Search:', searchTerm, 'Status:', statusFilter);            this.applyFilters();            if (typeof this.categoryRenderer.refreshCategoryList === 'function') {                await this.categoryRenderer.refreshCategoryList();            }        } catch (error) {            console.error('Failed to refresh categories (modal):', error);            this.showAlert('danger', 'Failed to load categories: ' + error.message);            if (typeof this.categoryRenderer.showEmptyState === 'function') {                this.categoryRenderer.showEmptyState();            }        } finally {            if (typeof this.categoryRenderer.hideLoadingState === 'function') {                this.categoryRenderer.hideLoadingState();            }        }    }    showAlert(type, message) {        if (window.showAlert) {            window.showAlert(type, message);        } else {            console.log(`${type.toUpperCase()}: ${message}`);        }    }    showDeleteModal() {        if (this.deleteModal && window.bootstrap) {            const modal = new bootstrap.Modal(this.deleteModal);            modal.show();        }    }    hideDeleteModal() {        if (this.deleteModal && window.bootstrap) {            const modal = bootstrap.Modal.getInstance(this.deleteModal);            if (modal) {                modal.hide();            }        }    }    async editCategory(categoryId) {        try {            const result = await this.api.getCategories();            if (!result.success || !result.data) {                throw new Error('Failed to load category data');            }            const category = result.data.find(cat => cat.category_id === categoryId);            if (!category) {                throw new Error('Category not found');            }            this.isEditMode = true;            this.currentCategoryId = categoryId;            const categoryIdField = document.getElementById('categoryId');            const categoryNameField = document.getElementById('categoryName');            const categoryDescField = document.getElementById('categoryDescription');            const categoryActiveField = document.getElementById('categoryActive');            if (categoryIdField) categoryIdField.value = category.category_id;            if (categoryNameField) categoryNameField.value = category.category_name;            if (categoryDescField) categoryDescField.value = category.description || '';            const parentCategoryField = document.getElementById('parentCategory') || document.getElementById('parentCategoryId');            if (parentCategoryField) {                parentCategoryField.value = category.parent_category_id || '';            }            if (categoryActiveField) {                const activeFlag = (category.hasOwnProperty('is_active') ? category.is_active : true);                categoryActiveField.checked = Boolean(activeFlag);            }            if (this.categoryRenderer && typeof this.categoryRenderer.renderParentCategoryOptions === 'function') {                this.categoryRenderer.renderParentCategoryOptions(result.data, categoryId);            }            this.updateFormTitle();            this.switchToForm();        } catch (error) {            console.error('Failed to load category for editing:', error);            this.showAlert('danger', 'Failed to load category: ' + error.message);        }    }    confirmDeleteCategory(categoryId, categoryName, productCount, subcategoryCount) {        this.currentDeleteCategoryId = categoryId;        this.currentDeleteForce = false;        const content = document.getElementById('categoryDeleteContent');        if (content) {            content.innerHTML = `                <p>Are you sure you want to delete this category?</p>                <div class="alert alert-info">                    <strong>Category:</strong> ${this.categoryRenderer.escapeHtml(categoryName)}<br>                    <strong>Products:</strong> ${productCount}<br>                    <strong>Subcategories:</strong> ${subcategoryCount}                </div>                ${(productCount > 0 || subcategoryCount > 0) ?                     '<p class="text-warning"><small><i class="bi bi-exclamation-triangle"></i> This category has dependencies. Deletion may be restricted.</small></p>' :                     '<p class="text-danger"><small>This action cannot be undone.</small></p>'                }            `;        }        this.showDeleteModal();    }    showSubmitProgress(loading) {        const submitBtn = this.form.querySelector('button[type="submit"]');        const spinner = submitBtn?.querySelector('.spinner-border');        if (loading) {            submitBtn.disabled = true;            if (spinner) spinner.classList.remove('d-none');        } else {            submitBtn.disabled = false;            if (spinner) spinner.classList.add('d-none');        }    }    showSuccessMessage(message) {        if (typeof window.showAlert === 'function') {            window.showAlert('success', message);        } else if (typeof showAlert === 'function') {            showAlert('success', message);        } else {            console.log('SUCCESS: ' + message);        }    }    showErrorMessage(message) {        if (typeof window.showAlert === 'function') {            window.showAlert('danger', message);        } else if (typeof showAlert === 'function') {            showAlert('danger', message);        } else {            console.error('ERROR: ' + message);        }    }    showFieldError(fieldId, message) {        const field = document.getElementById(fieldId);        if (!field) return;        const feedback = field.parentElement.querySelector('.invalid-feedback');        if (message) {            field.classList.add('is-invalid');            if (feedback) feedback.textContent = message;        } else {            field.classList.remove('is-invalid');            if (feedback) feedback.textContent = '';        }    }    clearFieldError(fieldId) {        this.showFieldError(fieldId, null);    }    hideModal() {        if (this.modal && window.bootstrap) {            try {                const modalInstance = bootstrap.Modal.getInstance(this.modal);                if (modalInstance) {                    modalInstance.hide();                } else {                    const newInstance = new bootstrap.Modal(this.modal);                    newInstance.hide();                }                setTimeout(() => {                    this.#forceModalCleanup();                }, 200);            } catch (error) {                console.error('Error hiding category modal:', error);                this.#forceModalCleanup();            }        }    }    hideDeleteModal() {        if (this.deleteModal && window.bootstrap) {            try {                const modalInstance = bootstrap.Modal.getInstance(this.deleteModal);                if (modalInstance) {                    modalInstance.hide();                } else {                    const newInstance = new bootstrap.Modal(this.deleteModal);                    newInstance.hide();                }                setTimeout(() => {                    this.#forceModalCleanup();                }, 200);            } catch (error) {                console.error('Error hiding delete modal:', error);                this.#forceModalCleanup();            }        }    }    #forceModalCleanup() {        const visibleModals = document.querySelectorAll('.modal.show');        const backdrops = document.querySelectorAll('.modal-backdrop');        if (visibleModals.length === 0) {            backdrops.forEach(backdrop => backdrop.remove());            document.body.classList.remove('modal-open');            document.body.style.overflow = '';            document.body.style.paddingRight = '';        }        if (this.modal && !this.modal.classList.contains('show')) {            this.modal.classList.remove('show');            this.modal.style.display = 'none';            this.modal.setAttribute('aria-hidden', 'true');        }        if (this.deleteModal && !this.deleteModal.classList.contains('show')) {            this.deleteModal.classList.remove('show');            this.deleteModal.style.display = 'none';            this.deleteModal.setAttribute('aria-hidden', 'true');        }    }}window.CategoryModal = CategoryModal;